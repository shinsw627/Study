# TIL 20211108 Kubernetes

### **📌 쿠버네티스의 등장**

**쿠버네티스(Kubernetes)**는 여러 서버로 구성된 클러스터 환경에서 컨테이너화된 애플리케이션의 자동 디플로이, 스케일링 등의 관리를 하기 위한 컨테이너 오케스트레이션 플랫폼이다. 특히 선언적 구성과 자동화를 모두 용이하게 해준다. 그전에 우선 컨테이너화된 애플리케이션의 배포 모델부터 알아보자.

[https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FL16Rl%2Fbtq0TvNkrPY%2FgO21AdXzKOjh3DhvdchBo1%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FL16Rl%2Fbtq0TvNkrPY%2FgO21AdXzKOjh3DhvdchBo1%2Fimg.png)

https://kubernetes.io/ko/docs/concepts/overview/what-is-kubernetes/

컨테이너 배포 모델을 이야기하기 위해서는 한참 전으로 거슬러 올라가 전통적인 배포 모델부터 이야기해야한다. 초기의 전통적인 배포모델은 하나의 물리 서버에 여러 애플리케이션을 실행했다. 당연히 하나의 물리서버에서 리소스를 할당하고 제한하는 방법이 없었기 때문에 **가상화**가 등장하게 되었다.

가상화된 배포 모델로 바뀌면서 하나의 호스트에서 VM간에 애플리케이션을 격리하여 실행하였다. 각 VM은 가상화된 하드웨어 상에서 자체 운영체제를 포함하는 하나의 완전한 머신이다. 독립적이며 격리되었기 때문에 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스 할 수 없으므로, 일정 수준의 보안성도 제공할 수 있었다. 가상화를 통해 물리서버에서 리소스를 효율적으로 활용할 수 있었고 애플리케이션을 추가하거나 업데이트하는 과정이 수월해졌다.

하지만 세상은 여기서 멈추지 않았다. 더 가볍고 더 수월한 배포 환경을 만들기 위해서 **컨테이너**가 등장하였다. 컨테이너는 격리된 환경에서 서로 다른 어플리케이션을 실행한다는 점이 VM과 유사하다. 결정적으로 다른 것은 컨테이너는 호스트 운영체제를 공유한다. **따라서 VM에 비해 가볍다고 말한다. 가볍다는 장점 덕분에 여러 서버에 복제 및 배포하여 이식할 수 있다**.

이러한 컨테이너화된 애플리케이션을 체계적으로 관리하기 위해서 쿠버네티스가 등장하였다. 쿠버네티스는 다수의 서버 위에서 실행하는 컨테이너를 관리하는 오케스트레이션을 수행한다. 쿠버네티스를 통해 컨테이너의 배포부터, 확장, 스케줄링, 네트워크 설정 등을 자동화할 수 있다.

### **📌 쿠버네티스의 기본 개념**

쿠버네티스의 가장 핵심은 **Desired State(원하는 상태)**이다. 쿠버네티스에서 desired state는 애플리케이션의 최종 배포 상태를 의미하는데, 사용자가 원하는 desired state를 쿠버네티스에게 알려주면 쿠버네티스는 **Current State(현재 상태)**가 desired state와 동일하게 되도록 작업을 수행한다. 즉 쿠버네티스가 알아서 장애를 복구해준다. 상태를 변경하는 주체는 컨트롤러인데 컨트롤러는 control-loop를 돌며 리소스를 모니터링한다.

https://theithollow.com/2019/09/16/kubernetes-desired-state-and-control-loops/

[https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJYmTi%2Fbtq0Ucz18cj%2FfY95ItsXfcYPSwYsUDob9k%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FJYmTi%2Fbtq0Ucz18cj%2FfY95ItsXfcYPSwYsUDob9k%2Fimg.png)

### **📌 쿠버네티스의 구조**

앞서 쿠버네티스는 여러 서버에 걸쳐 실행되는 컨테이너 애플리케이션을 관리한다고 하였다. 쿠버네티스 클러스터는 여러 컴포넌트들로 이루어져있으며 이들이 존재하는 서버를 **마스터 노드(서버)**와 **워커 노드(서버)**로 구분할 수 있다. 흔히 쿠버네티스는 서버를 **가축**에 비유하는데 하나의 무리로 관리하는 가축은 한마리마다 이름을 정해두는 것도 아니고 특별한 관리를 하는 것도 아니다. 쿠버네티스도 각각의 서버가 특별한 역할을 수행하는 것이 아니라 단순히 하나의 작업을 나누어 수행한다. 서버 하나를 특별하게 관리하는 것이 아닌 죽으면 새로 서버를 구축하는 형태인 것이다.

[https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpJiPg%2Fbtq0SlR28bv%2Fxa9cuw0iQzxFzZQNL52dSK%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FpJiPg%2Fbtq0SlR28bv%2Fxa9cuw0iQzxFzZQNL52dSK%2Fimg.png)

https://kubernetes.io/ko/docs/concepts/overview/components/

### Master Node

마스터 노드(master node)는 쿠버네티스의 클러스터 전체를 컨트롤하는 시스템으로 보통 관리자만 접근할 수 있도록 설정한다. 하나의 서버로 구축해도 문제는 없지만 고가용성을 위해 여러대의 서버에 구축하는 것이 일반적이다. 마스터 노드에 존재하는 컴포넌트는 아래와 같다.

**kube-apiserver**

api 서버는 쿠버네티스의 api를 노출하여 다른 컴포넌트들로부터 오는 이벤트에 대해 응답하는 역할을 한다. 클러스터에서는 api 서버가 중심이 되어 컴포넌트들의 통신이 이루어진다. 컴포넌트끼리 뿐만 아니라 사용자와의 상호작용도 api 서버에서 담당한다. 사용자가 입력한 명령을 받아서 다른 컴포넌트들의 처리 응답을 전달해준다. 또한 kube-apiserver는 수평으로 확장되도록 디자인되었다. 즉, 더 많은 인스턴스를 배포해서 확장할 수 있다. 여러 kube-apiserver 인스턴스를 실행하고, 인스턴스간의 트래픽을 균형있게 조절할 수 있다.

> 쿠버네티스의 선언형 명령어 kubectl
> 

**etcd(저장소)**

etcd는 모든 클러스터 데이터를 저장하는 저장소(DB) 역할을 수행한다. 흔히 생각하는 관계형 데이터베이스(Relational Database)가 아니라 key-value 저장소이다. 고가용성을 위해 etcd를 구축하여 백업을 할 수 있다.

**kube-scheduler**

스케줄러는 생성되었지만 배정되지 못하여 실행되지 않은 컨테이너를 감지하고 실행할 노드를 선택하는 역할을 한다. 스케줄링 결정을 위해서 고려되는 요소는 리소스에 대한 개별 및 총체적 요구 사항, 노드의 상태, 제약 조건등을 포함한다.

**kube-controller-manager(컨트롤러 집합)**

컨트롤러를 구동하는 컴포넌트로, 앞에서 설명한 control-loop를 돌면서 current state가 desired state로 되도록 바꾸어주는 역할을 담당한다. 컨트롤러의 종류에도 여러가지가 존재하는데 논리적으로 각 컨트롤러는 개별 프로세스이지만 복잡성을 낮추기 위해 모두 단일 바이너리로 컴파일되고 단일 프로세스 내에서 실행된다.

- 노드 컨트롤러: 노드가 다운되었을 때에 대응한다.
- 레플리케이션 컨트롤러: 레플리케이션 오브젝트에서 알맞은 수의 Pod를 유지한다.
- 엔드포인트 컨트롤러: 서비스와 Pod를 연결한다.
- 서비스 어카운트 & 토큰 컨트롤러: 새로운 네임스페이스에 대한 기본 계정과 API 접근 토큰을 생성한다.

**cloud-controller-manager(클라우드 컨트롤러)**

클라우드별 컨트롤 로직을 포함하는 쿠버네티스 컨트롤 플레인 컴포넌트이다. 클라우드 컨트롤러 매니저를 통해 클러스터를 클라우드에 연결하여 클라우드 플랫폼의 리소스를 추가 및 사용할 수 있다. kube-controller-manager와 마찬가지로 cloud-controller-manager도 논리적으로 독립적인 여러 control-loop를 단일 프로세스로 실행하는 단일 바이너리로 결합한다.

다음 컨트롤러들은 클라우드 플랫폼의 의존성을 가질 수 있다.

- 노드 컨트롤러: 노드가 응답을 멈춘 후 클라우드 상에서 삭제되었는지 판별하기 위해 클라우드 제공 사업자에게 확인하는 것
- 라우트 컨트롤러: 기본 클라우드 인프라에 경로를 구성하는 것
- 서비스 컨트롤러: 클라우드 제공 사업자 로드밸런서를 생성, 업데이트 그리고 삭제하는 것

### Worker Node

워커 노드는 마스터로부터 전달받은 명령에 따라 컨테이너를 실행한다.

**kubelet(노드 관리자)**

클러스터의 각 노드에서 실행되는 핵심 컴포넌트로 다양한 메커니즘을 통해 제공된 명세(Spec)의 집합을 받아서 컨테이너를 실행시킨다. 여기서 끝나는 것이 아니라 정상적으로 동작하는지 지속적으로 모니터링하고 주기적으로 마스터 노드의 api 서버와 통신하여 정보를 주고받는다.

**kube-proxy(네트워크 프록시)**

클러스터의 각 노드에서 실행되는 네트워크 프록시로, 쿠버네티스의 서비스 오브젝트를 구현한다. 즉 노드의 네트워크 규칙을 관리하여 서비스마다 개별 IP를 가질 수 있게 만들어주고 클러스터 내부나 외부의 트래픽을 Pod로 전달할 수있도록 해준다.

**container runtime(컨테이너 런타임)**

실제 컨테이너 실행을 담당하는 소프트웨어이다. 예를 들어 도커, CRI-O 등이 있다.

### **📌 쿠버네티스의 장점**

1. **실행환경 고립화** 쿠버네티스를 이용하면 개별 실행 환경에 고민할 필요없이 어디서든 실행할 수 있다. 실행 환경 자체가 가상 환경에 포함되어있기 때문이다.
2. **리소스 관리** 자체적으로 여러 서버에 나뉘어진 리소스를 체계적으로 관리할 수 있는 기능을 제공해주므로 수월하게 클러스터를 관리할 수 있다.
3. **서비스 디스커버리와 로드 밸런싱** 쿠버네티스는 DNS나 IP 주소를 사용하여 컨테이너를 노출할 수 있다. 컨테이너로 들어오는 트래픽이 많으면 로드 밸런싱을 통해 안정적인 배포가 이루어지도록 한다.
4. **스토리지 오케스트레이션** 로컬 저장소나 클라우드의 저장소와 같이 원하는 저장소 시스템을 자동으로 탑재 할 수 있다.
5. **자동화된 롤아웃과 롤백** 배포된 컨테이너의 current state를 desired state로 유지하기 위해 지속적으로 모니터링하고 처리하여 자동화된 롤백을 지원한다.
6. **장애 대응 수월** 프로세스마다 리소스 사용량을 제한함으로써 장애 발생시 다른 프로세스에 영향을 끼치지 않도록 설정할 수 있다. 더 나아가서는 노드에 이상이 생기면 서버 자체를 바꾸면 되므로 장애에 수월하게 대응할 수 있다.
7. **자동화된 복구(self-healing)** 실패한 컨테이너를 다시 시작하고 문제가 발생한 컨테이너를 교체하며 상태 검사에 응답하지 않는 컨테이너를 죽이는 등의 동작을 통해 클러스터의 desired state를 유지한다.
8. **배포 자동화** 쿠버네티스에서 자동으로 노드를 선택하여 컨테이너를 배치하므로 어플리케이션의 배포를 자동화할 수 있다.

### **📌 Pod 기본 개념**

Pod는 쿠버네티스에서 가장 기본이 되는 최소 실행 단위로 컨테이너를 포함한다. 쿠버네티스는 컨테이너를 개별로 하나씩 배포하는 것이 아니라 Pod 단위로 배포하는데 아무리 작은 프로세스라도 Pod를 통해 실행해야 한다. 즉 Pod로 프로세스를 실행하는 기본 가상 환경을 제공하는 것이다. Pod의 특징은 아래와 같다.

1️⃣ **한 개 이상의 컨테이너를 실행**

Pod는 한 개 이상의 컨테이너를 포함하는데 보통 한 개의 Pod당 한 개의 컨테이너를 가지는데 많게는 3개까지 가지기도 한다. 물론 3개보다 더 많이 실행할 수도 있지만 잘 쓰이지 않는다고 한다. 특히 여러개의 컨테이너를 실행하는 경우 쿠버네티스가 실행 순서를 보장하지는 않기 때문에 먼저 실행해야 하는 컨테이너가 있는 경우 initContainer를 통해 명시적으로 초기화 작업을 수행해주어야 한다.

2️⃣ **동일 노드에 할당**

Pod에 포함된 컨테이너들은 동일한 노드에 할당된다. 또한 동일한 생명주기를 가지게 되어 Pod가 삭제되면 Pod에 포함된 컨테이너가 모두 삭제된다.

3️⃣ **Pod만의 고유 IP 할당**

Pod는 노드와는 별개로 고유한 IP를 할당받아 Pod에 직접 접근이 가능하다. 포트포워딩과 같은 방법이 필요없이 다른 노드에 있는 Pod들도 서로의 고유한 IP를 통해 통신할 수 있다.

4️⃣ **Pod 내의 컨테이너간 IP 공유**

하나의 Pod 내에 있는 컨테이너들은 IP를 공유한다. 따라서 localhost로 컨테이너간 통신이 가능하다. 컨테이너는 Port를 통해 구분한다.

5️⃣ **볼륨 공유**

Pod 내에 존재하는 컨테이간에는 디스크 볼륨을 공유할 수 있다. 기존의 컨테이너로 분리된 어플리케이션은 컨테이너간 파일 시스템이 분리되기 때문에 다른 컨테이너의 볼륨에 접근할 수 없었다. 하지만 Pod에서는 컨테이너들이 동일한 볼륨을 사용하여 연결되고 공유한다.

쿠버네티스 리소스는 YAML 형태의 정의서로 표현될 수 있다. 그 중에서 Pod를 살펴보자. 아래는 nginx 이미지로 생성한 컨테이너를 한 개 가지고 있는 간단한 Pod YAML 정의서이다.

[https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUffF6%2Fbtq1E8vXxux%2FJEzlEkuhgwNUIekRBSsPBk%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FUffF6%2Fbtq1E8vXxux%2FJEzlEkuhgwNUIekRBSsPBk%2Fimg.png)

- apiVersion: 쿠버네티스의 API 버전으로 리소스간 충돌을 피하기 위한 scope
- kind: 리소스 종류 정의
- metadata: 리소스의 메타 데이터 정의(라벨, 이름 등)
- spec: 리소스에 대한 상세 스펙 정의(Pod에서는 생성하는 컨테이너의 정보 등을 포함)

> 🙋‍♂️ nginx가 뭔가요?
> 
> 
> nginx는 가벼움과 높은 성능을 목표로 하는 웹 서버 소프트웨어로 동시접속 처리에 특화되었다. 웹 서버, 리버스 프록시 및 메일 프록시 기능을 가진다. Apache와 비슷한 역할을 하는데, nginx는 오래전에 만들어진 아파치의 대항마로 등장하였다. 시대의 요구사항에 부응하여 등장한 만큼 더 적은 자원으로 빠르게 데이터를 서비스할 수 있는 특징이 있다.
> 

정의한 YAML 파일로 Pod를 생성해보자.

[https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeIXalR%2Fbtq1C2J1Tuj%2F1oyhjmLR2Z52PoWtgI2z80%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeIXalR%2Fbtq1C2J1Tuj%2F1oyhjmLR2Z52PoWtgI2z80%2Fimg.png)

이렇게 직접 YAML을 작성해서 리소스를 생성할 수도 있지만 kubectl run 명령의 --dry-run과 -oyaml 옵션 조합으로 리소스를 실제로  생성하지 않고 템플릿만 생성하는 것이 가능하다.

![Untitled](TIL%2020211108%20Kubernetes%2068f3756517e94adb9681cd46b3c3e08d/Untitled.png)

좋은 그림이라 들고와 봤다.

쿠버네틱스는 container orchestration 이라고 할 수 있다.
자동화된 컨테이너 배포 스케일링 관리 해주는 오픈소스 시스템이다.

선언적API

![Untitled](TIL%2020211108%20Kubernetes%2068f3756517e94adb9681cd46b3c3e08d/Untitled%201.png)