# 백엔드 예상 질문

- github issue 관리 사용하는 이유는 뭐죠?
    
    각 개발자들이 발생한 이슈를 공유하고 필요한 작업들이 어떤 상태인지를 쉽게 알 수 있습니다. 이슈를 실제로 처리하는 입장에서, 어느 브랜치에서 어떤이름으로 브랜치를 생성할지 어떤 후속 작업을 진행해야 하는지와 같은 고민을 줄일 수 있어서 작성하는 코드에만 집중하는 환경을 만들 수 있습니다. 잘 정립된 개발 프로세스는 생산성을 높이는 것에 기여하며, 작업의 진행을 매끄럽게 만들고 결과물의 퀄리티 또한 높이게 됩니다.
    
- 왜 GitHub Issues & Projects를 선택 하셨죠?
    
    저희가 알아본 툴이 몇개 있는데 Jira는 우선 금전적 비용이 발생하고 큰조직에서 태스크를 관리할 때 사용되는 툴이라 저희 프로젝트와는 맞지 않다고 생각했습니다. Trello 또한 괜찮은 태스크 관리 보드인데 현재 프로젝트의 요구사항으론 Github 외부의 트래커를 따로 쓸 필요는 없다고 생각했습니다.
    
- **개발 프로세스를 어떻게 사용(적용)하셨나요?**
    
    필요한 작업이 생기면 알맞는 라벨과 함께 이슈를 생성하고,  projects를 선택해 동기화시키고 이슈는 'To Do'에 위치하게 됩니다.
    해당 작업을 진행할 개발자가 정해지면 assign하고 issue/<이슈 번호> 네이밍을 가진 브랜치를 dev에서 체크아웃합니다. 작업이 완료되면 동료 개발자에게 리뷰를 요청하고 확인 후 dev에 merge하게 됩니다.
    문제 없이 작업이 완료된 것을 확인하였다면 issue를 close하고 작업 브랜치를 제거합니다.
    
- 왜 json을 사용하였죠?
    
    json은 자바스크립트를 사용하는 react 프론트엔드와 nodejs 백엔드에게 이만큼 편한 구조가 없다고 생각했습니다.
    
    동일한 데이터를 표현하더라고, json이 비교적 더 잘 경량화되어 있으며 가독성도 좋기 때문입니다.
    xml의 tree 구조는 배열을 표현하는데에 어려워서 자원을 표현하는 데에는 그리 효과적인 포맷은 아닌 것 같다고 판단했습니다.
    yaml은 관례상 직렬화 포맷으로 잘 사용하지 않는다고 하여서 쓰지 않았습니다.
    
    protobuf는 구글에서 개발한 데이터 교환 포맷인데 직렬화 역직렬화 속도가 빨라 성능상의 이점이 있고 api 문서화에도 이점이 많다고 들었습니다만 아직 저희들에게 익숙하지 않아 프로젝트가 지연될 우려가 있어서 나중에 시간이 나면 공부해보기로 하였습니다.
    
- 로그인 처리 방식을 설명해보세요
    
    
- JWT토큰을 access토큰과 refresh토큰 두 가지를 사용하셨는데 이유를 말씀해주시겠어요?
    
    보안적인 측면과 사용자의 인증에 관한 부담을 덜기 위해서 입니다.
    로그인이 되면 access토큰에는 사용자 정보를 담아 비교적 짧은 만료시간으로 발급(1시간정도)하고  refresh토큰은 비교적 긴 만료시간만을 설정(2주)하여 데이터 없이 발급하게 되며 DB에 저장되게 됩니다.
    사용자는 짧은기간의 access token이 만료되더라도 긴 refresh token을 통해 DB와 비교하여 새롭게 access token을 발급하여 사용자는 좀 더 안전하고 편하게 서비스를 이용할 수 있게 됩니다.
    
- JWT토큰을 access토큰과 refresh토큰 두 가지를 사용하셨는데 인증이 되는 과정을 설명해 주시겠어요?
    
    로그인이 되면 미들웨어를 통해 access토큰에는 사용자 정보를 담아 비교적 짧은 만료시간으로 발급(1시간정도)하고  refresh토큰은 비교적 긴 만료시간만을 설정(2주)하여 데이터 없이 발급하게 되며 각각 유저에 맞게 DB에 저장되게 됩니다.
    사용자는 짧은기간의 access token이 만료되더라도 긴 refresh token을 통해 DB와 비교하여 새롭게 access token을 발급하여 주게됩니다.
    
- 많은 access 토큰 refresh 토큰 구현 방식 중 두개를 한꺼번에 보내는 방법을 쓰는 이유는?
    
    처음에 직관적으로 생각 했던 방식
    
    1. 로그인을 하면  access 토큰  refresh 토큰을 생성하고 refresh 토큰은 DB저장 후 access토큰과 refresh 토큰을 클라이언트에 던져준다. 
    2. 클라이언트 access 토큰을 서버에 보내주고 서버는 검증한다.
    3. 만료가 되면 클라이언트는 갖고있던 refresh 토큰을 서버에 보낸다. 
    4. 서버는 refresh 토큰을 DB에 저장된  refresh 토큰과 검증을 한후 만료 되지 않았으면 access 토큰을 클라이언트에 다시 보낸다.
    
    이 방법은 서버 통신이 딱 봐도 많아 보인다.  access 토큰은 만료시간을  짧게 가져가는게 보안  에 좋기 때문에 access 토큰을 최대한 많이 발급받아야 되는데 통신이 많다면 리소스도 많이 들어가게 되어 부담이 많이 될 거라 생각
    
    두번째 소셜에 로그인시에 토큰을 받게 되는데 네이버 같은 경우 access token  refresh 토큰을 같이 보내 준다. 이와같이 두개를 한꺼번에 보내는 방식 
    
    1. 클라이언트가 서버에서 요청시에 계속 해서 access 토큰과 refresh 토큰을 던져준다.
    2. 서버는 access토큰과 refresh 토큰을 검증하고 access 토큰만 만료 될 경우 재 발급한다.
- 소셜로그인이 어떻게 구현되어 있는지 설명해 주시겠어요?
    
    프론트엔드에서 해당소셜업체에 로그인 인가코드를 요청하고 소셜업체의 엑세스 토큰을 받아와서 백엔드 서버에 전달해 줍니다. 그러면 백엔드에서 엑세스 토큰을 소셜업체에 보내어 사용자 정보를 요청합니다. 그 정보를 토대로 가입여부를 판단하여 회원가입을 진행하며 유저의 정보를 짧은 만료시간의 access 토큰에 담고 정보 없는 긴 만료시간의 refresh토큰을 발급하여 프론트엔드에게 전달하게 됩니다.
    
    [https://camo.githubusercontent.com/9032cf853ebdf1c9219fd1c48f58df4193f039deb59b2289b2af8bd81d862d9e/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d6874747073253341253246253246626c6f672e6b616b616f63646e2e6e6574253246646e25324662426c58584f253246627471335574536777427325324638664f4e6338583576364c336f7262766a717850336b253246696d672e706e67](https://camo.githubusercontent.com/9032cf853ebdf1c9219fd1c48f58df4193f039deb59b2289b2af8bd81d862d9e/68747470733a2f2f696d67312e6461756d63646e2e6e65742f7468756d622f523132383078302f3f73636f64653d6d746973746f72793226666e616d653d6874747073253341253246253246626c6f672e6b616b616f63646e2e6e6574253246646e25324662426c58584f253246627471335574536777427325324638664f4e6338583576364c336f7262766a717850336b253246696d672e706e67)
    
- 소셜로그인을 세가지나 하셨네요? 그 이유를 설명해주세요 그리고 어려운 점은 없었나요?
    
    저희 서비스는 가벼운 주제로 핸드폰으로 이용하는 경우가 많을 것으로 예상되어 최대한 많은 소셜로그인을 이용하였습니다.
    어려운 점으로는 첫 소셜로그인 구현을 백엔드에서 passport라이브러리를 이용하여 프론트는 요청만 보내면 소셜사에 인가코드와 엑세스토큰 발급과 사용자 정보 요청 모든 과정을 진행하여 프론트에 결과와 jwt 토큰만 전달해주는 형태로 구현하려고 했습니다.하지만 cors에러에 막혀 이틀을 통째로 날리고 결국 프론트와 나누어 프론트에서 인가코드 요청과 엑세스토큰 요청 과정을 맡고 백엔드에 엑세스토큰을 보내어 백엔드에서 엑세스 토큰을 통해 소셜회사에서 사용자 정보를받아 JWT토큰을 발급하는 현재의 형태로 바꾸게 되었습니다.
    
- 왜 Bearer 인증 방식(or JWT 인증 방식)을 사용하셨죠?
    
    
    - Basic은 **ID와 비밀번호를 base64 인코딩**하는 방식이다. base64는 **별도의 key 없이도 복호화가 가능**한 인코딩이므로, 안전하지 않다.
    - **OAuth 1.0a는 Bearer 인증 표준이 아니다.** Bearer 스펙을 명시한 [RFC 6750](https://tools.ietf.org/html/rfc6750)에는 큰 글씨로 **'The OAuth 2.0 Authorization Framework'**라고 되어 있기까지 하다.
    - Bearer에서 사용하는 OAuth 2.0 방식의 인증은 확장성이 매우 높다. **'Facebook 계정으로 로그인'**과 같은 기능이 OAuth로 구현되었다. 되도록 이런 흐름에 낄 수 있다면 좋겠지만, OAuth 2.0은 자체 암호화를 지원하지 않기 때문에 **HTTPS**를 쓰는 것을 권고하고 있고, 돈이 들어가야 하는 부분이다. 인증 정책은 나중에 **HTTPS 관련 비용 문제를 해결하고 나서 변경해도 괜찮을 것 같다**는 판단이다. 또한, 스펙 자체에서 **명확하게 정의하지 않은 부분**이 꽤 있어서 그만큼 고민이 깊어진다고 한다.
    - **Bearer에 JWT를 사용**하거나, **JWT라는 타입을 쓰는 것도 표준이 아니다.** 그러나 HTTPS 문제로 OAuth 2.0을 보류하게 되니, **대신 쓸 토큰 기반 인증 시스템**으로 JWT가 가장 쓸만 하다.
    - **'보호된 리소스에 대한 접근 권한을 부여받기 위해 제시하는 유일한 작업이 토큰을 전달하는 것 뿐'**일 때, 이 토큰을 **bearer token**이라고 부를 수 있다. 따라서 JWT를 사용하는 인증 방식도 사실상 bearer라는 문맥에서 벗어나지 않으며, 단지 **bearer token을 생성하기 위해 OAuth 2.0 관련 사양을 사용하지 않는 것 뿐**이다. **Authorization 헤더**를 사용하고, **디지털 방식으로 서명(sign)**된 토큰을 사용한다면, 이정도 사이즈의 프로젝트에서는 비용을 들이면서까지 OAuth 2.0을 완전히 수행하려 하지 않아도 된다고 생각한다.
    - JWT는 사용 사례가 많고, 거인의 어깨(잘 만들어진 라이브러리, 예제 등)가 잘 준비되어 있다.
- 헤더 Authorization 으로 인증정보를 보냈는데 그 이유는 무엇인가요?
    
    인증 데이터는 메타데이터의 성격이 강한데요, request body와는 어울리지 않습니다. 그리고 req.body를 사용할 수 없는 메소드들도 많고요 get, head, delete 등이 그렇습니다. 그래서 저희는 표준화 되어있는 Authorization 헤더를 사용하였습니다.
    
- 왜 mysql을 사용하셨나요?
    
    nosql의 장점은 schemaless여서 더욱 유연한 형태로 데이터를 저장할 수 있다는 장점이 있긴하지만 저희 프로젝트에서는 고정된 데이터 형식이라 스키마의 변경 또한 없을것으로 예상되었고 데이터의 양 또한 많지 않아 데이터의 정확성을 보장하는 mysql을 사용하였습니다.
    (현재 documentDB 아시아+서울에서도 잘 사용가능하다고 합니다. 그래서 그 부분 제외했습니다.)
    
- sequelize를 사용한 이유는 무엇인가요?
    
    sequelize를 이용하면 쿼리를 함수와 값으로 표현할 수 있어 코드를 작성함에도 용이하고 코드의 가독성도 올라가기 때문에 사용하였습니다. 복잡한 쿼리나 퍼포먼스가 중요한 부분은 sequelize.query()를 사용하여 처리하였습니다.
    
- 왜 Artillery 를 사용하였나요?
    
    Artillery 는 node.js로 작성된 성능테스트 도구인데요 시나리오 테스트가 가능하며 javascript로 로직을 추가 할 수 있고 가볍고 편하게 쓸 수 있는 테스트 도구라 사용하였습니다.
    
- scale out 말고 다른 성능 개선방법은 생각해 보셨나요?
    
    [쿼리 최적화: 빠른 쿼리를 위한 7가지 체크리스트 ✅. DB에 대한 데이터 분석가의 에티켓 | by daniel | WATCHA | Medium](https://medium.com/watcha/%EC%BF%BC%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94-%EC%B2%AB%EA%B1%B8%EC%9D%8C-%EB%B3%B4%EB%8B%A4-%EB%B9%A0%EB%A5%B8-%EC%BF%BC%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-7%EA%B0%80%EC%A7%80-%EC%B2%B4%ED%81%AC-%EB%A6%AC%EC%8A%A4%ED%8A%B8-bafec9d2c073)
    
    기본적으로 쿼리 성능개선을 위해 기존 DB값에 별도의 연산을 걸지 않도록 설계하거나 LIKE문 사용시 와일드카드 문자열%를 string 앞부분에 배치하지 않도록 설계하고 select distinct와 union distinct와 같은 중복 값 제거 연산은 줄이는 방향으로 개선하거나 group by 연산 시 where 절로 데이터 크기를 미리 줄여 연산 효율 증대시키거나 inner join 시 크기가 가장 큰 테이블을 from 절에 배치하는 등 세세한 부분에 신경을 쓰는 방향과
    해시조인과 같은 방법들에 대해 앞으로 공부해볼 예정입니다.
    
- 검색기능이 있던데 어떻게 구현되어 있죠? (그 후 어떻게 개선할지도 적어주세요 정민님ㅎ;)
    
    like 사용시 검색어 단어 단위로 검색이 가능하며 검색단어가 많이 포함된 순으로 우선순위까지 주려고 한다면 쿼리가 매우 길어지고 복잡해진다. 따라서 mySQL에서 지원하느 검색엔진과 유사한 기능인 FULL TEXT INDEX와 NGRAM을 활용하여 검색단어를 최소단위로 잘라 인덱싱 하고 역색인으로 데이터를 가져오는 방법으로 구현되어 있습니다. 추가적으로 elasticsearch를 구현하여 mySQL의 부하를 줄이며 검색성능을 향상시키고 모니터링을 통해 분석할 수 있게 할 예정입니다.
    
- 쿠버네티스 관련 질문 필요합니다.(적용안해서 갠츈)
    
    
- 혹은 젠킨스를 사용한 이유는 뭔가요?
    
    CI/CD 구현과 관계가 있습니다. 개발자들의 코드를 계속 해서 통합하고  사용가능한 서비스로 전달하는 모든 과정을 지속가능형태로 자동화 하기 위해서 젠킨스로 배포 자동화하였습니다.
    
- 젠킨스를 선택한 이유는?
    
    가장 오래된 서비스 이고 관련 레퍼런스들이 많을거라 생각 했고 모든기능을 무료로 사용할 수 있었고 저희가 궁극적으로 Dock형 환경을 구축 하려고 하는데 트레비스나 깃랩같은 도구에 비해 Docker친화적이면서 파이프라인 설계 문법자체도 어려워보이지 않아서 충분히 가능하다고 판단했습니다. → 
    
    그러나...젠킨스를 사용할때 하나 부터 열까지 전부 환경설정을 구축해야 하며 각종 방화벽작업이나 서버의 관리 운용등 많은 리소스를 요구했습니다. 
    
    그래서 저희는 gitlab, trevis 도 고려해볼 예정입니다.
    
     
    
- nginx를 왜 사용하셨나요?
    
    express 서버 앞단에서 동작하여 뒷단의 서버의 정보를 보호해 주는 역할을 합니다. 따라서 보안성을 높힐수 있고 proxy 설정으로 쿠키제어도 할수 있었습니다. 그리고 후에 nginx를 활용하여 로드벨런싱 셋팅을 할예정이기 필요한
    
- 서버에서 가장 크게 고민했던 부분은 무엇인가요?
    
    
- 테스트 코드가 없는데 왜안했노! TDD 개발에 대해 어떻게 생각하는지?
    
    테스트 코드의 중요성은 충분히 인지하고 있습니다. 저희도 TDD를 고려했었지만 프로젝트 기획단계에서의 지연이 있었어서 TDD를 하기에는 시간적 한계가 있었습니다.
    
    저희의 남은 기간동안의 과제가 될 것입니다. 
    
- 백엔드 아키텍쳐에 대해서 전반적인 설명 부탁드립니다(발표 때 이미 할거 같은데? 또? 저번기수에서 질문했길래 일단 적어둡니다 ㅎㅎ)
    
    
- RDS 뭡니까?
    
    AWS 클라우드에서 관계형 데이터베이스를 더 쉽게 설치, 운영 및 확장할 수 있는 웹 서비스입니다.
    
- 조회수처리에서 쿠키를 사용하였는데 쿠키 보안적인 부분은 어떻게 하실건지
    
    ■조치방법 : 아래 방법들 중에서 가능한 것을 선택해서 적용함. 
    
    1) 쿠키값 암호화를 통한 쿠키불법 변조방지(서버에서 전송받은 쿠키를 복호화 한후, 위/변조 되었는지 확인) 
    
    2) 쿠키값에 대한 Message Digest(예, MD5, SHA-1 등) 값의 첨부 및 검증을 통한위,변조탐지(아래예제참조) 
    
    3) 쿠키에 세션값을 저장하는 대신어플리케이션서버세션사용(사용하는웹어플리케이션서버가지원하는지확인필요)