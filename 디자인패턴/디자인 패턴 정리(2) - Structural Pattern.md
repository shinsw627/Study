## 어댑터(Adapter)

**어댑터 패턴은 서로 다른 인터페이스를 가진 두 클래스를
어댑터 클래스로 인터페이스를 통일 시켜 사용하는 방법이다.**

서로 다른 두 클래스(Client 와 Adaptee) 가 있고, 이 둘은 그대로 둔 채 이 둘의 인터페이스를 연결하고자 어댑터 클래스를 만들어 사용하는 구조를 어댑터 패턴이라고 한다.
이 패턴은 이미 정의된 3자의 인터페이스를 자신의 인터페이스의 모양으로 "인터페이스의 변경" 하고 싶을 때 사용한다.

### 장점

- 기존 클라이언트 단의 코드 수정 최소화.
- 클라이언트는 연동부분을 몰라도, 새로운 코드의 기능을 일관되게 사용가능.

### 단점

어댑터 클래스에서 통일 시켜주는 부분을 하나씩 구현해야 함.

### 구조

![](https://images.velog.io/images/shinsw627/post/ba797745-e788-4f08-8097-21dae0944434/image.png)

## 컴퍼지트(Composite)

**컴퍼지트 패턴은 단일 객체와 그 객체들을 가지는 집합 객체를
같은 타입으로 취급하며, 트리 구조로 객체들을 엮는 패턴이다.**

여러 개의 클래스가 크게 보면 같은 요소(Component) 에 속하지만, 여기에 속한 어떤 클래스(Composite)가 자기 자신 혹은 다른 클래스(Leaf)를 가질 수 있는 구조를 컴퍼지트 패턴이라고 한다.
이 패턴은 같은 개념의 클래스들 간에 소유 개념을 나타낸 트리 형태 묶고 싶을 때 사용한다.

### 장점

- 객체들이 모두 같은 타입으로 취급되기 때문에 새로운 클래스 추가가 용이하다.
- 단일객체, 집합객체 구분하지 않고 코드 작성이 가능하다.

### 단점

설계를 일반화 시켜 객체간의 구분, 제약이 힘들다.

### 활용상황

- 객체들 간에 계급 및 계층구조가 있고 이를 표현해야할 때
- 클라이언트가 단일 객체와 집합 객체를 구분하지 않고 동일한 형태로 사용하고자 할 때

### 구조

![](https://images.velog.io/images/shinsw627/post/6b797c89-d2f3-431c-af29-07b16af56484/image.png)

**Component**

- Leaf와 Composite 가 구현해야하는 Interface 로, Leaf 와 Composite 는 모두 Component 라는 같은 타입으로 다뤄진다.
  **Leaf**
- 단일 객체로 Composite 의 부분(자식) 객체로 들어가게 된다.
  이 때, Component 의 형태로 들어간다.
  **Composite**
- 집합 객체로 Leaf 객체나 Composite 를 부분(자식)으로 둔다.
  이 때, Component 의 형태로 들어간다.
  클라이언트는 이 Composite 를 통해 부분 객체들 (Leaf 나 Composite) 을 다룰 수 있다.
